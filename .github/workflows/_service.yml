# Build and Deploy Jobs
name: _ServiceDeployment

on:
  workflow_call:
    inputs:
      workspace:
        required: true
        type: string
      environment:
        required: true
        type: string
      services:
        required: true
        type: string
    secrets:
      BITWARDEN_TOKEN:
        required: true

env:
  # Environment variables for the pipeline
  VAR_PATH_TEMP: /tmp/app

jobs:
  # Setup the deployment of the service
  setup:
    name: Setup Service
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    outputs:
      server: ${{ steps.manager.outputs.serverinfo }}
      matrix: ${{ steps.services.outputs.matrix }}
    steps:
      # Check out the platform repo
      - name: Check Out
        uses: actions/checkout@v4

      # Restore Terraform Cache
      - name: Fetch Terraform Output
        uses: ./.github/actions/get-terraform
        with:
          workspace: ${{ inputs.workspace }}
          environment: ${{ inputs.environment }}
          VAR_PATH_TEMP: ${{ env.VAR_PATH_TEMP }}
          TERRAFORM_API_TOKEN: ${{ secrets.TERRAFORM_API_TOKEN }}

      # Parse Terraform Output to find Manager Servers
      - name: Parse Swarm Servers
        id: manager
        run: |
          # Read raw JSON
          matrix=$(jq -c '.' "${{ env.VAR_PATH_TEMP }}/tf_output.json")
          echo "================"
          echo "$matrix"
          echo "================"
          # Load helper functions
          source "./deploy/scripts/utilities.sh"
          # Determine workspace file
          WORKSPACE_FILE=$(get_workspace_file "./deploy/workspaces" "${{ inputs.workspace }}") || exit 1
          echo "Using workspace file: $WORKSPACE_FILE"
          # Determine manager label
          MANAGER_ID=$(get_manager_id "$WORKSPACE_FILE") || exit 1
          echo "Using manager label: $MANAGER_ID"
          # Extract only the manager node
          MANAGER_DATA=$(jq -c --arg label "$MANAGER_ID" '.include[] | select(.label == $label)' "${{ env.VAR_PATH_TEMP }}/tf_output.json")
          echo "================"
          echo "Filtered manager data: $MANAGER_DATA"
          echo "================"
          # Export to GitHub Actions output
          echo "serverinfo=$MANAGER_DATA" >> "$GITHUB_OUTPUT"

      # This step filters service definitions from the registry
      # based on a list of requested service IDs (passed in as `inputs.services`).
      # Example: inputs.services: "traefik,site"
      # The script reads `registry/*.json`, each containing a `.service.id` field,
      # and constructs a GitHub Actions matrix output including only the matched services.
      # Output format:
      # {
      #   "include": [
      #     { "id": "traefik" },
      #     { "id": "site" }
      #   ]
      # }
      - name: Parse service matrix
        id: services
        run: |
          # inputs.services is a comma-separated list or JSON array of service IDs
          SERVICES_JSON=$(jq -R '[split(",")[]]' <<< "${{ inputs.services }}")

          echo "Filtering for services: $SERVICES_JSON"
          
          FIRST=true
          shopt -s nullglob
          FILES=(registry/*.json)
          if [ ${#FILES[@]} -eq 0 ]; then
            echo "No JSON files found in registry/"
            echo 'matrix={"include": [{ "id": "", "name": "" }]}' >> "$GITHUB_OUTPUT"
            exit 0
          fi

          MATRIX='{ "include": ['

          for file in "${FILES[@]}"; do
            ID=$(jq -r '.service.id' "$file")

            # Include everything if SERVICES=* or match against SERVICES_JSON
            if [[ "${{ inputs.services }}" == "*" ]] || jq -e --arg id "$ID" 'index($id)' <<< "$SERVICES_JSON" >/dev/null; then
              SERVICE_JSON=$(jq -c '.service' "$file")

              # Optional: enrich or customize structure here
              #ENTRY=$(jq -n --argjson svc "$SERVICE_JSON" '{ id: $svc.id, name: $svc.name }')
              ENTRY=$(jq -n --argjson svc "$SERVICE_JSON" '{ id: $svc.id }')

              if [ "$FIRST" = true ]; then
                MATRIX+="$ENTRY"
                FIRST=false
              else
                MATRIX+=",$ENTRY"
              fi
            fi
          done

          MATRIX+='] }'
          COMPACT_MATRIX=$(jq -c '.' <<< "$MATRIX")
          echo "Generated matrix: $COMPACT_MATRIX"
          echo "matrix=$COMPACT_MATRIX" >> "$GITHUB_OUTPUT"

  deploy:
    name: Deploy Services
    needs: [setup]
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    if: ${{ always() && !contains(needs.*.result, 'failure') }}
    strategy:
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
    steps:
      # Do we need to run?
      - name: Skip Deployment
        if: matrix.id == ''
        run: |
          echo "No services to deploy â€” skipping empty matrix list."

      # Check out the repo
      - name: Check Out Platform
        uses: actions/checkout@v4
        if: matrix.id != ''

      # Load service metadata from registry
      # Outputs
      # - repository
      # - ref
      # - servicedata
      - name: Load Service Metadata
        id: load
        if: matrix.id != ''
        run: |
          SERVICE_FILE="registry/${{ matrix.id }}.json"
          echo "Reading $SERVICE_FILE"
          SERVICE_DATA=$(jq -c . "$SERVICE_FILE")
          echo "Reading Repository and Ref"
          SERVICE_REPO=$(jq -r '.service.repo' <<< "$SERVICE_DATA")
          SERVICE_REF=$(jq -r '.service.ref // "main"' <<< "$SERVICE_DATA")
          echo "repository=$SERVICE_REPO" >> "$GITHUB_OUTPUT"
          echo "ref=$SERVICE_REF" >> "$GITHUB_OUTPUT"
          echo "service=$SERVICE_DATA" >> "$GITHUB_OUTPUT"

      # Debug Service Info
      - name: Debug Service Info
        if: matrix.id != ''
        run: |
          echo Service ${{ matrix.id }}
          echo Service ${{ steps.load.outputs.service }}
          echo Server Info ${{ needs.setup.outputs.server }}
          echo Repo ${{ steps.load.outputs.repository }}
          echo Ref ${{ steps.load.outputs.ref }}

      # Clone the service repository
      - name: Clone Service Repo
        uses: actions/checkout@v4
        if: matrix.id != ''
        with:
          repository: ${{ steps.load.outputs.repository }}
          ref: ${{ steps.load.outputs.ref }}
          path: service/${{ matrix.id }}

      # Fetch Bitwarden Secrets
      - name: Fetch Bitwarden CLI
        uses: ./.github/actions/get-bitwarden
        if: matrix.id != ''
        with:
          bitwarden_token: ${{ secrets.BITWARDEN_TOKEN }}

      # Configure Service
      - name: Configure Service
        if: matrix.id != ''
        env:
          VAR_WORKSPACE: ${{ inputs.workspace }}
          VAR_ENVIRONMENT: ${{ inputs.environment }}
          VAR_SERVICEDATA: ${{ steps.load.outputs.service }}
          VAR_SERVERINFO: ${{ needs.setup.outputs.server }}
        run: |
          echo "[*] Deploying service ${{ matrix.ip }} ..."
          chmod +x deploy/scripts/deploy-swarm-services.sh
          .deploy/scripts/deploy-swarm-services.sh
          echo "[*] Deploying service ${{ matrix.ip }} ... DONE"
