# Build and Deploy Jobs
name: _WorkspaceDeployment

on:
  workflow_call:
    inputs:
      workspace_name:
        required: true
        type: string
      workspace_file:
        required: true
        type: string
      infrastructure:
        required: true
        type: boolean
    secrets:
      BITWARDEN_TOKEN:
        required: true

env:
  # Environment variables for the pipeline
  VAR_PATH_INSTALL: /opt/install/app
  VAR_PATH_TEMP: /tmp/app

jobs:

  # Terraform Plan and Apply
  # This job will run if the cache is not hit or if the initialize input is set to true
  # Stores the output in a JSON file and uploads it as an artifact and caches it for future runs
  terraform:
    name: Terraform Apply
    runs-on: ubuntu-latest
    if: inputs.infrastructure == true
    steps:
      # Setup YQ CLI
      - name: Setup YQ
        uses: ./.github/actions/get-yq

      # Setup Bitwarden CLI
      - name: Setup Bitwarden
        uses: ./.github/actions/get-bitwarden
        with:
          bitwarden_token: ${{ secrets.BITWARDEN_TOKEN }}

      # Set up the Terraform CLI
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7
          terraform_wrapper: false

      # Check out the repo
      - name: Check Out
        uses: actions/checkout@v4

      # Run Terraform to create docker swarm cluster
      - name: Run Terraform
        id: tfapply
        working-directory: ./deploy/terraform
        env:
          VAR_WORKSPACE_NAME: ${{ inputs.workspace_name }}
          VAR_WORKSPACE_FILE: ${{ inputs.workspace_file }}
          VAR_PATH_INSTALL: ${{ env.VAR_PATH_INSTALL }}
          VAR_PATH_TEMP: ${{ env.VAR_PATH_TEMP }}
          BITWARDEN_TOKEN: ${{ secrets.BITWARDEN_TOKEN }}
        run: |
          echo "[*] Server deployment and configuration ..."
          chmod +x ../scripts/run_terraform.sh
          ../scripts/run_terraform.sh
          echo "[+] Server deployment and configuration ... DONE"
      
      # Upload the Terraform output as an artifact
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: terraform-output-${{ inputs.workspace_name }}
          path: ${{ env.VAR_PATH_TEMP }}/tf_output.json
          if-no-files-found: error
      
      # Check if Terraform cache exists
      - name: Check Cache
        id: check-cache
        uses: actions/cache/restore@v4
        with:
          path: ${{ env.VAR_PATH_TEMP }}/tf_output.json
          key: terraform-output-${{ inputs.workspace_name }}

      # Upload the Terraform output as a job output
      - name: Cache Output
        if: steps.check-cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: ${{ env.VAR_PATH_TEMP }}/tf_output.json
          key: terraform-output-${{ inputs.workspace_name }}

  # Download the Terraform output artifact and parse it to find Swarm servers
  # This job will run if the cache is not hit or if the initialize input is set to true
  # Parses the output to find Swarm servers and sets them as a matrix for the next jobs
  restore:
    name: Download Terraform Output
    runs-on: ubuntu-latest
    needs: [terraform]
    if: always()
    outputs:
      matrix: ${{ steps.parse.outputs.matrix }}
    steps:
      # Download Terraform Artifact
      - name: Download Artifact
        if: inputs.infrastructure == true
        uses: actions/download-artifact@v4
        with:
          name: terraform-output-${{ inputs.workspace_name }}
          path: ${{ env.VAR_PATH_TEMP }}

      # Restore Terraform Cache
      - name: Restore Cache
        id: restore-cache
        if: inputs.infrastructure != true
        uses: actions/cache/restore@v4
        with:
          path: ${{ env.VAR_PATH_TEMP }}/tf_output.json
          key: terraform-output-${{ inputs.workspace_name }}

      # Check if the artifact exists
      - name: Validate Output
        run: |
          if [ ! -f ${{ env.VAR_PATH_TEMP }}/tf_output.json ]; then
            echo "[!] Artifact terraform-output-${{ inputs.workspace_name }} not found or tf_output.json missing. Exiting."
            exit 1
          fi

      # Parse Terraform Output to find Swarm Servers
      - name: Parse Servers
        id: parse
        run: |
          matrix=$(jq -c '.' ${{ env.VAR_PATH_TEMP }}/tf_output.json)
          echo "================"
          echo "$matrix"
          echo "================"
          echo "matrix=$matrix" >> $GITHUB_OUTPUT

  # Initialize the Swarm Cluster
  # This job will run if the cache is not hit or if the initialize input is set to true
  # Initializes the Swarm cluster by setting up keys, firewalls, disks, docker, gluster
  initialization:
    name: Initialize Cluster
    needs: [restore]
    runs-on: ubuntu-latest
    if: ${{ inputs.infrastructure == true }}
    strategy:
      matrix: ${{ fromJson(needs.restore.outputs.matrix) }}
    steps:
      # Setup YQ CLI
      - name: Setup YQ
        uses: ./.github/actions/get-yq

      # Check out the repo
      - name: Check Out
        uses: actions/checkout@v4

      # Set up GitHub Secrets
      - name: General Secrets
        uses: bitwarden/sm-action@v2
        id: get-secrets
        with:
          access_token: ${{ secrets.BITWARDEN_TOKEN }}
          secrets: |
            f16fffe2-77b7-4d20-bf6c-b2c9015c71d3 > KAMATERA_PRIVATE_KEY

      # Set up SSH connection
      - name: Setup SSH
        env:
          KAMATERA_PRIVATE_KEY: ${{ steps.get-secrets.outputs.KAMATERA_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "$KAMATERA_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      # Step: Copy the key securely to the remote server using scp
      - name: Private Key
        run: |
          scp -o StrictHostKeyChecking=no ~/.ssh/id_rsa root@${{ matrix.ip }}:/root/.ssh/id_rsa_temp || { echo "[x] Failed to transfer private key to remote server"; exit 1; }

      # Step: Initialize the Swarm cluster
      - name: Initialize Cluster
        env:
          VAR_WORKSPACE: ${{ inputs.workspace_name }}
        run: |
          echo "[*] Initializing swarm cluster on ${{ matrix.ip }} ..."
          chmod +x deploy/scripts/apply_initialization.sh
          ./deploy/scripts/apply_initialization.sh "${{ matrix.ip }}" "${{ matrix.private_ip }}" "${{ matrix.manager_ip }}"
          echo "[*] Initializing swarm cluster on ${{ matrix.ip }} ...DONE"
